#if( $union.packageName != "" )
package $union.packageName;
#end

#foreach( $importLine in $union.imports )
import#if( $importLine.static ) static#end $importLine.pattern;
#end

#set( $tp = $util.toTypeParameterCode($union.typeParameters) )
#set( $ta = $util.toTypeArgumentsCode($union.typeParameters) )
#set( $d = "$" )
public abstract class $union.typeName#if( !$tp.empty )<$tp>#end {
    #foreach( $product in $union.productTypes )
    public final static class $product.typeName#if( !$tp.empty )<$tp>#end extends $union.typeName#if( !$ta.empty )<$ta>#end {
        #foreach( $field in $product.fields )
        private#if( $field.final ) final#end#if( $field.transient ) transient#end#if( $field.volatile ) volatile#end $field.type $field.name;
        #end

        public ${product.typeName}() { }

        #if( !$product.fields.empty )
        public ${product.typeName}(${util.toParameterList($product.fields)}) {
            #foreach( $field in $product.fields )
            this.$field.name = $field.name;
            #end
        }

        #end
        #foreach( $field in $product.fields )
        public#if( $field.synchronized ) synchronized#end $field.type ${util.toGetterName($field)}() {
            return $field.name;
        }

        #if( !$field.final )
        public#if( $field.synchronized ) synchronized#end void ${util.toSetterName($field)}($field.type $field.name) {
            this.$field.name = $field.name;
        }

        #end
        #end
        public <${d}T> ${d}T when(Switch#if( !$ta.empty )<${d}T, $ta>#else<${d}T>#end cases) {
            return cases.is(this);
        }

    }

    #end
    interface Switch#if( !$tp.empty )<${d}T, $tp>#else<${d}T>#end {
        #foreach( $product in $union.productTypes )
        ${d}T is($product.typeName#if( !$ta.empty )<$ta>#end it);
        #end
    }

    ${union.typeName}() { }

    public abstract <${d}T> ${d}T when(Switch#if( !$ta.empty )<${d}T, $ta>#else<${d}T>#end cases);
}